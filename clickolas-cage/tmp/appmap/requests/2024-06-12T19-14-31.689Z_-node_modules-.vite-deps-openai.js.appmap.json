{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/openai.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:5173",
          "Connection": "keep-alive",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
          "Accept": "*/*",
          "Sec-Fetch-Site": "none",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "empty",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "appland_session=bFU5p0cvqrcXlz2oQfgEZG3%2BQjfds2AwmlOA%2Fx5fhQLjPvVHIKrHyvnbeq5nw8c5sME56znPsnpSSzB3nr%2BHfdk9sEC9MgOgNKjgjD8qlzGqDVuwRPr30ch96LWGIDwuITrAUwQGqlUw7%2Fdsq0tjrfHFPTlemq71kQtCAIi9JTRWo5tLPJlG%2F9JtfTuiWIfWg8X67ZkAOuaapIHdaA5w5QtwMr7h34LfseImCERQpzoz9xTqJYqSi2SJ9RE1eVw2jyYFG9IGPA4d1USUIXvAmeaMOQ9Z%2BDmKhiIRXve6%2BzO47%2F2RW1kaH2PND2r0EKz%2BaWMbrXswEaj2kjwx09pTJANR5arO0I9c2RelyrURJyvI%2FZ8OwnG99VyxbE2scovqFvxwhmhXr1KDOxpRle3VOJSpxXtFaDjv2TSSbtqGkIj4T51u58xasM4KbZUpapu5OQ5ENf%2FSMADW4DHmCrSQJ14SgVbNtrazlgwdph5p0AKax1l0Bw7j0jz2SGT9C5HMnzVyZdV59G6paFrgLqvtGuXdWr4VeJt2tPVftjki2S0LpmpTAacYMTeiz0JRvAUI2MTy5coFmozGwP2tYolztMsGb%2Bss8Pp0ZRYy8EsEs78L1J1nDMR5VCJ5yVhSq8JXZA7Misee05vblyt4OMHf9CA4AMzWpe2NbExRxiHuW%2Bkx%2F83vj%2Btrqn1QRG33cQUOn3jl8nfSuSLj5p0K5PYVYnXJu8E7RhAyqpC6J23a%2F8B4qsDAOrIrUYPQAWaYOsjd0i3Q5y49d77RlVc7zyyLJxFNVWLlYCD5BrfOMpyF2f9InowPEQei23xjT4UE0W3dXZP1xhk5wDvQ--zbb2b%2Flld908TQxF--8LcY2kn8%2BBw8bSaDiyP6LQ%3D%3D"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'85b4035a'",
          "class": "String"
        },
        {
          "name": "t",
          "value": "'1718219671672'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"26f6c-mY7Ut5p4ORyzYi/Ry55K/fcpoP4\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  __export\n} from \"/node_modules/.vite/deps/chunk-6TJCVOLN.js?v=85b4035a\";\n\n// node_modules/openai/version.mjs\nvar VERSION = \"4.36.0\";\n\n// node_modules/openai/_shims/registry.mjs\nvar auto = false;\nvar kind = void 0;\nvar fetch2 = void 0;\nvar Request2 = void 0;\nvar Response2 = void 0;\nvar Headers2 = void 0;\nvar FormData2 = void 0;\nvar Blob2 = void 0;\nvar File2 = void 0;\nvar ReadableStream2 = void 0;\nvar getMultipartRequestOptions = void 0;\nvar getDefaultAgent = void 0;\nvar fileFromPath = void 0;\nvar isFsReadStream = void 0;\nfunction setShims(shims, options = { auto: false }) {\n  if (auto) {\n    throw new Error(`you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`);\n  }\n  if (kind) {\n    throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${kind}'\\``);\n  }\n  auto = options.auto;\n  kind = shims.kind;\n  fetch2 = shims.fetch;\n  Request2 = shims.Request;\n  Response2 = shims.Response;\n  Headers2 = shims.Headers;\n  FormData2 = shims.FormData;\n  Blob2 = shims.Blob;\n  File2 = shims.File;\n  ReadableStream2 = shims.ReadableStream;\n  getMultipartRequestOptions = shims.getMultipartRequestOptions;\n  getDefaultAgent = shims.getDefaultAgent;\n  fileFromPath = shims.fileFromPath;\n  isFsReadStream = shims.isFsReadStream;\n}\n\n// node_modules/openai/_shims/MultipartBody.mjs\nvar MultipartBody = class {\n  constructor(body) {\n    this.body = body;\n  }\n  get [Symbol.toStringTag]() {\n    return \"MultipartBody\";\n  }\n};\n\n// node_modules/openai/_shims/web-runtime.mjs\nfunction getRuntime({ manuallyImported } = {}) {\n  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \\`import … from 'openai'\\`:\n- \\`import 'openai/shims/node'\\` (if you're running on Node)\n- \\`import 'openai/shims/web'\\` (otherwise)\n`;\n  let _fetch, _Request, _Response, _Headers;\n  try {\n    _fetch = fetch;\n    _Request = Request;\n    _Response = Response;\n    _Headers = Headers;\n  } catch (error) {\n    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);\n  }\n  return {\n    kind: \"web\",\n    fetch: _fetch,\n    Request: _Request,\n    Response: _Response,\n    Headers: _Headers,\n    FormData: (\n      // @ts-ignore\n      typeof FormData !== \"undefined\" ? FormData : class FormData {\n        // @ts-ignore\n        constructor() {\n          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);\n        }\n      }\n    ),\n    Blob: typeof Blob !== \"undefined\" ? Blob : class Blob {\n      constructor() {\n        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);\n      }\n    },\n    File: (\n      // @ts-ignore\n      typeof File !== \"undefined\" ? File : class File {\n        // @ts-ignore\n        constructor() {\n          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);\n        }\n      }\n    ),\n    ReadableStream: (\n      // @ts-ignore\n      typeof ReadableStream !== \"undefined\" ? ReadableStream : class ReadableStream {\n        // @ts-ignore\n        constructor() {\n          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);\n        }\n      }\n    ),\n    getMultipartRequestOptions: async (form, opts) => ({\n      ...opts,\n      body: new MultipartBody(form)\n    }),\n    getDefaultAgent: (url) => void 0,\n    fileFromPath: () => {\n      throw new Error(\"The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads\");\n    },\n    isFsReadStream: (value) => false\n  };\n}\n\n// node_modules/openai/_shims/index.mjs\nif (!kind)\n  setShims(getRuntime(), { auto: true });\n\n// node_modules/openai/error.mjs\nvar error_exports = {};\n__export(error_exports, {\n  APIConnectionError: () => APIConnectionError,\n  APIConnectionTimeoutError: () => APIConnectionTimeoutError,\n  APIError: () => APIError,\n  APIUserAbortError: () => APIUserAbortError,\n  AuthenticationError: () => AuthenticationError,\n  BadRequestError: () => BadRequestError,\n  ConflictError: () => ConflictError,\n  InternalServerError: () => InternalServerError,\n  NotFoundError: () => NotFoundError,\n  OpenAIError: () => OpenAIError,\n  PermissionDeniedError: () => PermissionDeniedError,\n  RateLimitError: () => RateLimitError,\n  UnprocessableEntityError: () => UnprocessableEntityError\n});\nvar OpenAIError = class extends Error {\n};\nvar APIError = class _APIError extends OpenAIError {\n  constructor(status, error, message, headers) {\n    super(`${_APIError.makeMessage(status, error, message)}`);\n    this.status = status;\n    this.headers = headers;\n    this.request_id = headers == null ? void 0 : headers[\"x-request-id\"];\n    const data = error;\n    this.error = data;\n    this.code = data == null ? void 0 : data[\"code\"];\n    this.param = data == null ? void 0 : data[\"param\"];\n    this.type = data == null ? void 0 : data[\"type\"];\n  }\n  static makeMessage(status, error, message) {\n    const msg = (error == null ? void 0 : error.message) ? typeof error.message === \"string\" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return \"(no status code or body)\";\n  }\n  static generate(status, errorResponse, message, headers) {\n    if (!status) {\n      return new APIConnectionError({ cause: castToError(errorResponse) });\n    }\n    const error = errorResponse == null ? void 0 : errorResponse[\"error\"];\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n    return new _APIError(status, error, message, headers);\n  }\n};\nvar APIUserAbortError = class extends APIError {\n  constructor({ message } = {}) {\n    super(void 0, void 0, message || \"Request was aborted.\", void 0);\n    this.status = void 0;\n  }\n};\nvar APIConnectionError = class extends APIError {\n  constructor({ message, cause }) {\n    super(void 0, void 0, message || \"Connection error.\", void 0);\n    this.status = void 0;\n    if (cause)\n      this.cause = cause;\n  }\n};\nvar APIConnectionTimeoutError = class extends APIConnectionError {\n  constructor({ message } = {}) {\n    super({ message: message ?? \"Request timed out.\" });\n  }\n};\nvar BadRequestError = class extends APIError {\n  constructor() {\n    super(...arguments);\n    this.status = 400;\n  }\n};\nvar AuthenticationError = class extends APIError {\n  constructor() {\n    super(...arguments);\n    this.status = 401;\n  }\n};\nvar PermissionDeniedError = class extends APIError {\n  constructor() {\n    super(...arguments);\n    this.status = 403;\n  }\n};\nvar NotFoundError = class extends APIError {\n  constructor() {\n    super(...arguments);\n    this.status = 404;\n  }\n};\nvar ConflictError = class extends APIError {\n  constructor() {\n    super(...arguments);\n    this.status = 409;\n  }\n};\nvar UnprocessableEntityError = class extends APIError {\n  constructor() {\n    super(...arguments);\n    this.status = 422;\n  }\n};\nvar RateLimitError = class extends APIError {\n  constructor() {\n    super(...arguments);\n    this.status = 429;\n  }\n};\nvar InternalServerError = class extends APIError {\n};\n\n// node_modules/openai/streaming.mjs\nvar Stream = class _Stream {\n  constructor(iterator, controller) {\n    this.iterator = iterator;\n    this.controller = controller;\n  }\n  static fromSSEResponse(response, controller) {\n    let consumed = false;\n    async function* iterator() {\n      if (consumed) {\n        throw new Error(\"Cannot iterate over a consumed stream, use `.tee()` to split the stream.\");\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of _iterSSEMessages(response, controller)) {\n          if (done)\n            continue;\n          if (sse.data.startsWith(\"[DONE]\")) {\n            done = true;\n            continue;\n          }\n          if (sse.event === null) {\n            let data;\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n            if (data && data.error) {\n              throw new APIError(void 0, data.error, void 0, void 0);\n            }\n            yield data;\n          } else {\n            let data;\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n            if (sse.event == \"error\") {\n              throw new APIError(void 0, data.error, data.message, void 0);\n            }\n            yield { event: sse.event, data };\n          }\n        }\n        done = true;\n      } catch (e) {\n        if (e instanceof Error && e.name === \"AbortError\")\n          return;\n        throw e;\n      } finally {\n        if (!done)\n      ... (149586 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.002031035997788422
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.0",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v18.19.0"
    },
    "app": "clickolas-cage",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/openai.js (200) — 2024-06-12T19:14:31.689Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/openai.js"
        }
      ]
    }
  ]
}